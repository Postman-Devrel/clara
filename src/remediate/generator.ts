/**
 * Remediation Plan Generator for Clara
 *
 * Transforms Clara analysis reports into structured remediation plans
 * with copy-paste prompts for Postman Agent Mode.
 */

import type { AnalysisReport, PriorityFix, EndpointReport } from '../types/index.js';

interface RemediationItem {
  rank: number;
  checkId: string;
  checkName: string;
  severity: string;
  pillar: string;
  endpointsAffected: number;
  whyItMatters: string;
  whatIsWrong: string;
  agentModePrompt: string;
  specFix?: string;
  affectedEndpoints: string[];
}

interface RemediationPlan {
  apiName: string;
  apiVersion: string;
  currentScore: number;
  agentReady: boolean;
  totalIssues: number;
  quickWins: RemediationItem[];
  foundationFixes: RemediationItem[];
  polish: RemediationItem[];
}

/**
 * Generate a full remediation plan from an analysis report
 */
export function generateRemediationPlan(report: AnalysisReport): RemediationPlan {
  const items = report.priorityFixes.map((fix, index) =>
    buildRemediationItem(fix, index + 1, report)
  );

  return {
    apiName: report.api.name,
    apiVersion: report.api.version,
    currentScore: report.summary.overallScore,
    agentReady: report.summary.agentReady,
    totalIssues: items.length,
    quickWins: items.filter(
      (i) => i.severity === 'low' || i.severity === 'medium'
    ),
    foundationFixes: items.filter((i) => i.severity === 'high'),
    polish: [],
    // Move critical to front of foundation, everything else stays
  };
}

/**
 * Render a remediation plan as markdown
 */
export function renderRemediationMarkdown(report: AnalysisReport): string {
  const plan = generateRemediationPlan(report);
  const lines: string[] = [];

  // Header
  lines.push(`# API Remediation Plan`);
  lines.push('');
  lines.push(`> Generated by Clara for **${plan.apiName}** v${plan.apiVersion}`);
  lines.push('');

  // Executive Summary
  lines.push(`## Executive Summary`);
  lines.push('');
  lines.push(`| Metric | Value |`);
  lines.push(`|--------|-------|`);
  lines.push(`| Current Score | ${plan.currentScore}% |`);
  lines.push(`| AI Agent Ready | ${plan.agentReady ? 'Yes' : 'No (target: 70%+)'} |`);
  lines.push(`| Total Issues | ${plan.totalIssues} |`);
  lines.push(`| Critical/High | ${report.summary.criticalFailures + report.priorityFixes.filter((f) => f.severity === 'high').length} |`);
  lines.push(`| Total Endpoints | ${report.summary.totalEndpoints} |`);
  lines.push('');

  // Pillar breakdown
  lines.push(`### Pillar Scores`);
  lines.push('');
  lines.push(`| Pillar | Score | Status |`);
  lines.push(`|--------|-------|--------|`);
  for (const pillar of report.pillars) {
    const status =
      pillar.score >= 80 ? 'Good' : pillar.score >= 50 ? 'Needs Work' : 'Critical';
    lines.push(`| ${pillar.name} | ${pillar.score}% | ${status} |`);
  }
  lines.push('');

  // How to use this document
  lines.push(`## How to Use This Plan`);
  lines.push('');
  lines.push(`This plan contains ready-to-use prompts for Postman Agent Mode.`);
  lines.push('');
  lines.push(`1. Open your API collection in Postman`);
  lines.push(`2. Launch Agent Mode (look for the AI icon)`);
  lines.push(`3. Copy each prompt below and paste it into Agent Mode`);
  lines.push(`4. Replace \`@[Your Collection]\` with your actual collection using the @ menu`);
  lines.push(`5. Review Agent Mode's changes before accepting`);
  lines.push('');
  lines.push(`For spec-level fixes (marked with "Spec Fix"), update your OpenAPI spec directly using the provided YAML/JSON snippets.`);
  lines.push('');

  // Critical fixes first
  const criticalItems = report.priorityFixes
    .filter((f) => f.severity === 'critical')
    .map((fix, i) => buildRemediationItem(fix, i + 1, report));

  if (criticalItems.length > 0) {
    lines.push(`## Critical Fixes (Must Do)`);
    lines.push('');
    lines.push(`These block AI agents from functioning. Fix these first.`);
    lines.push('');
    for (const item of criticalItems) {
      renderItem(lines, item);
    }
  }

  // High fixes
  const highItems = report.priorityFixes
    .filter((f) => f.severity === 'high')
    .map((fix, i) => buildRemediationItem(fix, criticalItems.length + i + 1, report));

  if (highItems.length > 0) {
    lines.push(`## High Priority Fixes`);
    lines.push('');
    lines.push(`AI agents will struggle significantly without these.`);
    lines.push('');
    for (const item of highItems) {
      renderItem(lines, item);
    }
  }

  // Medium/Low fixes
  const otherItems = report.priorityFixes
    .filter((f) => f.severity === 'medium' || f.severity === 'low')
    .map((fix, i) =>
      buildRemediationItem(
        fix,
        criticalItems.length + highItems.length + i + 1,
        report
      )
    );

  if (otherItems.length > 0) {
    lines.push(`## Quick Wins`);
    lines.push('');
    lines.push(`Lower severity but easy to fix. Good for incremental score improvement.`);
    lines.push('');
    for (const item of otherItems) {
      renderItem(lines, item);
    }
  }

  // Batch prompt section
  lines.push(`## Batch Prompt (All-in-One)`);
  lines.push('');
  lines.push(`If you prefer, paste this single prompt into Agent Mode to address multiple issues at once:`);
  lines.push('');
  lines.push('```');
  lines.push(generateBatchPrompt(report));
  lines.push('```');
  lines.push('');

  // Footer
  lines.push('---');
  lines.push(`*Generated by Clara v${report.claraVersion} | ${new Date(report.generatedAt).toISOString()}*`);

  return lines.join('\n');
}

function renderItem(lines: string[], item: RemediationItem): void {
  lines.push(`### #${item.rank}: ${item.checkName}`);
  lines.push('');
  lines.push(`| | |`);
  lines.push(`|---|---|`);
  lines.push(`| **Severity** | ${item.severity.toUpperCase()} |`);
  lines.push(`| **Pillar** | ${item.pillar} |`);
  lines.push(`| **Endpoints Affected** | ${item.endpointsAffected} |`);
  lines.push('');
  lines.push(`**Why it matters:** ${item.whyItMatters}`);
  lines.push('');
  lines.push(`**Problem:** ${item.whatIsWrong}`);
  lines.push('');

  if (item.agentModePrompt) {
    lines.push(`**Agent Mode Prompt:**`);
    lines.push('```');
    lines.push(item.agentModePrompt);
    lines.push('```');
    lines.push('');
  }

  if (item.specFix) {
    lines.push(`**Spec Fix (apply to OpenAPI spec):**`);
    lines.push('```yaml');
    lines.push(item.specFix);
    lines.push('```');
    lines.push('');
  }

  if (item.affectedEndpoints.length > 0 && item.affectedEndpoints.length <= 10) {
    lines.push(`**Affected endpoints:**`);
    for (const ep of item.affectedEndpoints) {
      lines.push(`- \`${ep}\``);
    }
    lines.push('');
  }

  lines.push('---');
  lines.push('');
}

function buildRemediationItem(
  fix: PriorityFix,
  rank: number,
  report: AnalysisReport
): RemediationItem {
  const affected = findAffectedEndpoints(fix.checkId, report.endpoints);
  const pillar = fix.checkId.split('_')[0] ?? '';
  const pillarName = PILLAR_NAMES[pillar] || pillar;

  return {
    rank,
    checkId: fix.checkId,
    checkName: fix.checkName,
    severity: fix.severity,
    pillar: pillarName,
    endpointsAffected: fix.endpointsAffected,
    whyItMatters: fix.summary,
    whatIsWrong: buildProblemDescription(fix),
    agentModePrompt: buildAgentModePrompt(fix, affected, report),
    specFix: buildSpecFix(fix),
    affectedEndpoints: affected.map((e) => `${e.method} ${e.path}`),
  };
}

function findAffectedEndpoints(
  checkId: string,
  endpoints: EndpointReport[]
): EndpointReport[] {
  return endpoints.filter((ep) =>
    ep.checks.some((c) => c.id === checkId && c.status === 'failed')
  );
}

function buildProblemDescription(fix: PriorityFix): string {
  if (fix.fix?.description) {
    return fix.fix.description;
  }
  return fix.summary;
}

function buildAgentModePrompt(
  fix: PriorityFix,
  affected: EndpointReport[],
  report: AnalysisReport
): string {
  const checkId = fix.checkId;
  const apiName = report.api.name;
  const endpointList =
    affected.length <= 5
      ? affected.map((e) => `${e.method} ${e.path}`).join(', ')
      : `${affected.length} endpoints`;

  // Generate specific prompts based on check type
  const promptMap: Record<string, string> = {
    // Metadata
    META_001: `In @[Your Collection] for ${apiName}, add a unique operationId to each request that is missing one. Use descriptive camelCase names like "listUsers", "createOrder", "getProductById". The following endpoints need operationIds: ${endpointList}`,

    META_002: `In @[Your Collection] for ${apiName}, rename the following operationIds to be more descriptive. Use camelCase with a verb prefix (get, list, create, update, delete) followed by the resource name: ${endpointList}`,

    META_003: `In @[Your Collection] for ${apiName}, add a short summary (one sentence, under 120 chars) to each request that is missing one. The summary should describe what the endpoint does. Affected: ${endpointList}`,

    META_004: `In @[Your Collection] for ${apiName}, add a detailed description to each request that is missing one. Include what the endpoint does, when to use it, and any important notes. Affected: ${endpointList}`,

    META_005: `In @[Your Collection] for ${apiName}, organize requests into folders by resource type (e.g., Users, Orders, Products). Each request should have at least one tag/folder. Affected: ${endpointList}`,

    META_006: `In @[Your Collection] for ${apiName}, mark deprecated endpoints clearly in the description with "[DEPRECATED]" prefix and add a note about what to use instead.`,

    // Errors
    ERR_001: `In @[Your Collection] for ${apiName}, add test scripts to the following endpoints that validate error responses. For each endpoint, add tests for 400 (bad request), 401 (unauthorized), 403 (forbidden), and 404 (not found) responses. Verify the response body contains "code" and "message" fields: ${endpointList}`,

    ERR_002: `In @[Your Collection] for ${apiName}, create a standard error response example for each endpoint. The error response should follow this schema: { "error": { "code": "string", "message": "string", "details": [] } }. Add this as a documented response for all 4xx and 5xx status codes: ${endpointList}`,

    ERR_003: `In @[Your Collection] for ${apiName}, document all possible error codes for each endpoint in the description. Include the HTTP status code, error code string, and when it occurs. Affected: ${endpointList}`,

    ERR_004: `In @[Your Collection] for ${apiName}, add descriptive error messages to test assertions. Each error response test should verify the message field contains helpful text that explains what went wrong and how to fix it: ${endpointList}`,

    ERR_005: `In @[Your Collection] for ${apiName}, add tests for 5xx server error responses. Verify the API returns structured error responses (not HTML stack traces) for 500, 502, 503 status codes: ${endpointList}`,

    ERR_006: `In @[Your Collection] for ${apiName}, add documentation to error response descriptions about retry behavior. Include whether the request is safe to retry, suggested wait time, and any Retry-After header support: ${endpointList}`,

    ERR_007: `In @[Your Collection] for ${apiName}, add tests that verify rate limit responses (429 Too Many Requests) include proper headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, and Retry-After: ${endpointList}`,

    ERR_008: `In @[Your Collection] for ${apiName}, add tests for request validation. Send requests with invalid field types, missing required fields, and out-of-range values. Verify the error response identifies which field failed and why: ${endpointList}`,

    // Introspection
    INTRO_001: `In @[Your Collection] for ${apiName}, add type information to all request parameters. Each parameter should have a type (string, integer, boolean, array, object) and format (e.g., date-time, email, uuid) where applicable: ${endpointList}`,

    INTRO_002: `In @[Your Collection] for ${apiName}, add format specifications to parameters that have specific formats. Use standard formats: date-time, email, uri, uuid, int32, int64, float, double: ${endpointList}`,

    INTRO_003: `In @[Your Collection] for ${apiName}, mark all required parameters explicitly. Update request descriptions to list which parameters are required vs optional: ${endpointList}`,

    INTRO_005: `In @[Your Collection] for ${apiName}, add descriptions to all request parameters. Each description should explain what the parameter does, valid values, and any constraints: ${endpointList}`,

    INTRO_006: `In @[Your Collection] for ${apiName}, add enum values to parameters that accept a fixed set of values. List all valid options in the parameter description: ${endpointList}`,

    // Naming
    NAME_001: `In @[Your Collection] for ${apiName}, standardize naming to use consistent casing across all endpoints. Use camelCase for query parameters and request body fields, kebab-case for URL paths: ${endpointList}`,

    NAME_003: `In @[Your Collection] for ${apiName}, update request methods to follow REST semantics: GET for retrieval (no request body), POST for creation, PUT for full replacement, PATCH for partial update, DELETE for removal: ${endpointList}`,

    // Predictability
    PRED_001: `In @[Your Collection] for ${apiName}, add example response bodies to each request. Include both success (200/201) and error (400/404) response examples with realistic data: ${endpointList}`,

    PRED_003: `In @[Your Collection] for ${apiName}, add pagination tests to list endpoints. Verify responses include pagination metadata (total, page, per_page, next_page) and test with limit/offset or cursor parameters: ${endpointList}`,

    PRED_006: `In @[Your Collection] for ${apiName}, document idempotency behavior for write endpoints. Add notes about which operations are idempotent and whether they support Idempotency-Key headers: ${endpointList}`,

    // Documentation
    DOC_001: `In @[Your Collection] for ${apiName}, add a comprehensive collection description. Include: what the API does, base URL, authentication method, rate limits, and links to full documentation.`,

    DOC_003: `In @[Your Collection] for ${apiName}, create an "Authentication" folder with example requests showing how to authenticate. Include setup instructions for API keys, OAuth tokens, or whatever auth method the API uses. Add a collection-level auth configuration.`,

    // Performance
    PERF_001: `In @[Your Collection] for ${apiName}, add response time assertions to all requests. Use pm.test to verify responses complete within acceptable thresholds (e.g., under 2000ms for reads, under 5000ms for writes): ${endpointList}`,

    PERF_002: `In @[Your Collection] for ${apiName}, add tests that check for rate limit headers in responses. Verify X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset headers are present: ${endpointList}`,

    // Discoverability
    DISC_002: `In @[Your Collection] for ${apiName}, set the base URL as a collection variable. Add environment variables for different environments (production, staging, sandbox) with their respective URLs.`,

    DISC_003: `In @[Your Collection] for ${apiName}, add contact information to the collection description: support email, documentation URL, and status page URL.`,
  };

  // Return specific prompt or generate a generic one
  if (promptMap[checkId]) {
    return promptMap[checkId];
  }

  // Generic fallback
  return `In @[Your Collection] for ${apiName}, fix the "${fix.checkName}" issue. ${fix.summary}. This affects: ${endpointList}`;
}

function buildSpecFix(fix: PriorityFix): string | undefined {
  if (!fix.fix?.example) return undefined;
  return fix.fix.example;
}

function generateBatchPrompt(report: AnalysisReport): string {
  const apiName = report.api.name;
  const criticalFixes = report.priorityFixes.filter(
    (f) => f.severity === 'critical' || f.severity === 'high'
  );

  if (criticalFixes.length === 0) {
    return `Review @[Your Collection] for ${apiName} and add comprehensive tests, documentation, and error handling examples for all endpoints.`;
  }

  const fixDescriptions = criticalFixes
    .slice(0, 8) // Keep it manageable
    .map((f, i) => `${i + 1}. ${f.checkName}: ${f.summary}`)
    .join('\n');

  return (
    `Review and fix the following issues in @[Your Collection] for ${apiName}:\n\n` +
    `${fixDescriptions}\n\n` +
    `For each issue, update the affected requests with proper tests, documentation, and examples. ` +
    `Add test scripts that validate both success and error responses. ` +
    `Create comprehensive documentation for each endpoint.`
  );
}

const PILLAR_NAMES: Record<string, string> = {
  META: 'Metadata',
  ERR: 'Errors',
  INTRO: 'Introspection',
  NAME: 'Naming',
  PRED: 'Predictability',
  DOC: 'Documentation',
  PERF: 'Performance',
  DISC: 'Discoverability',
};
